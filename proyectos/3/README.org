#+title: Asignaci√≥n de memoria en un sistema real
#+options: toc:nil num:nil

#+begin_src yaml
Planteamiento: 2020.04.24
Entrega: 2020.05.07
#+end_src

Pueden [[./calificaciones.org][consultar los comentarios y calificaciones del proyecto aqu√≠]].

Todos los sistemas operativos de uso general al d√≠a de hoy utilizan un
modelo de memoria basado en la /paginaci√≥n/, y /casi/ siempre (si le
concedemos la excepci√≥n a uno que otro sistemas construidos para el
/tiempo real duro/) memoria virtual.

Vamos a ver qu√© tanto podemos aprender u obtener de esta
informaci√≥n. Este proyecto buscar√° llevarlos a demostrar sus
conocimientos al extraer informaci√≥n de la memoria de procesos
reales. El proyecto consta de dos partes:

** Reimplementaci√≥n de =pmap=

En Linux, les he mostrado que hay varias maneras para obtener la
informaci√≥n de la asignaci√≥n de memoria a un proceso. En clase usamos
por conveniencia la salida de =pmap=.

Trabajemos tan cerca como se pueda de la informaci√≥n /cruda/, tal como
nos las da el sistema operativo: Quiero que me presenten con una
implementaci√≥n b√°sica y un poquito ampliada /hecha por ustedes/ de
=pmap=.

Sugiero que usen como fuente para implementarlo la informaci√≥n que nos
da Linux en =/proc/${PID}/maps= y =/proc/${PID}/smaps=. Su programa
debe recibir como entrada el mapa de memoria de /cualquier proceso/
(al que tenga permiso de lectura, naturalmente), y entregar:

- Identificaci√≥n de las secciones en memoria, indicando el tama√±o de
  cada una de ellas. Adem√°s de las regiones /cl√°sicas/ que estudiamos,
  les pido que indiquen claramente las regiones correspondientes a
  /bibliotecas de sistema/ y a otros /archivos mapeados a memoria/.
- Representaci√≥n visual de la memoria del proceso. Naturalmente, no
  espero que sea a escala (a fin de cuentas, ¬øc√≥mo se ver√≠a un proceso
  de apenas 4MB ante la inmensidad de un espacio de direccionamiento
  de 48 bits? üòâ

  La representaci√≥n visual puede ser a partir de algo [[./ejemplo/repr_visual_bash_rpi0][como mi ejemplo]]
  (ver un poquito m√°s adelante para mayores detalles. Pero... ¬°√âchenle
  creatividad! Pueden generar una imagen (dando mucha mayor
  resoluci√≥n), presentar cada secci√≥n con un color distinto, etc.

  Ojo, mi ejemplo est√° construido a partir de procesar los archivos
  [[./ejemplo/maps_bash_rpi0.txt][maps_bash_rpi0.txt]] y [[./ejemplo/smaps_bash_rpi0.txt][smaps_bash_rpi0.txt]], que fueron obtenidos en
  una Raspberry Pi 0. Menciono esto porque es una plataforma de /32
  bits/ ‚Äî Y se nota cuando ven las direcciones. 

*** Puede serles de utilidad...

Para reimplementar =pmap=, puede resultarles conveniente leer el
[[https://gitlab.com/procps-ng/procps/-/blob/master/pmap.c][c√≥digo fuente en C de pmap]]. Su lectura, a pesar de ser c√≥digo fuente
productivo en C con cosa de 20 a√±os de antig√ºedad, no est√° demasiado
m√°s all√° de lo que espero de ustedes üòâ.

Pueden referirse a la [[https://github.com/mmalecki/procps/blob/86073c3b5145fd7596a74642a15b9ad38ea488c2/pmap.c][primera versi√≥n funcional de =pmap=]] (de octubre
de 2002), pero no garantizo que siga funcionando: es posible que el
formato de la informaci√≥n provista por Linux haya cambiado.

** ¬øY realmente se acomoda as√≠?

Ya que pueden entender el acomodo del proceso en memoria y saben
extraerle su informaci√≥n... ¬°Verifiquemos si realmente funciona as√≠!

Para la segunda parte, les pido que identifiquen la regi√≥n de memoria
(que puede ser obtenida de ejecutar el programa que desarrollaron para
la primera parte del proyecto en que encuentren a los /s√≠mbolos/
(nombres de variables y funciones) y a los /datos/ (contenido de
variables) de un programa real. Para esto, prepar√© un programa ejemplo
en C, [[./donde_en_la_memoria/donde_en_la_memoria.c][donde_en_la_memoria.c]]. El programa es trivial, aunque presenta
la informaci√≥n de forma casi anti-organizada /a prop√≥sito/ para
ilustrarlo m√°s claramente.

Lo compil√© en una computadora x86, y a partir de su ejecuci√≥n, obtuve
los siguientes archivos:

- Compil√© el programa:
  - A ensamblador, usando =gcc -S donde_en_la_memoria.c=, obteniendo
    [[./donde_en_la_memoria/donde_en_la_memoria.s][donde_en_la_memoria.s]].
  - A ejecutable, usando =gcc -o donde_en_la_memoria
    donde_en_la_memoria.c=, obteniendo [[./donde_en_la_memoria/donde_en_la_memoria][donde_en_la_memoria]].
- El programa imprime su identificador de proceso al ejecutarse,
  obtenido con =getpid()=. Para los siguientes archivos, digamos que
  el PID fue =12345=.
- Usando =gcore -a 12345= y dicho identificador del proceso, obtuve el
  volcado de su memoria en ejecuci√≥n, en [[./donde_en_la_memoria/donde_en_la_memoria.core][donde_en_la_memoria.core]].
  Para interpretar este =core=, hay muchas herramientas disponibles.
  - Una de las m√°s socorridas, aunque no necesariamente de las m√°s
    amigables, es el depurador GNU, =gdb=. Para ejecutarlo, desde el
    directorio donde tengan a =donde_en_la_memoria.*=, ejecuten
    simplemente =gdb donde_en_la_memoria -c donde_en_la_memoria.core=.
  - Probablemente les resulte m√°s directo llegar a resultados si
    inspeccionan el =core= usando =objdump=...
  - Las herramientas de depuraci√≥n requieren, s√≠, de saber qu√© estamos
    esperando de ellas. Me atrevo a dejarles una liga a una pregunta
    en /StackOverflow/ con varias explicaciones interesantes que les
    pueden servir: [[https://stackoverflow.com/questions/8305866/how-do-i-analyze-a-programs-core-dump-file-with-gdb-when-it-has-command-line-pa][How do I analyze a program's core dump file with
    GDB when it has command-line parameters?]]
  - Cuando quieran sencillamente examinar un archivo binario y buscar
    patrones a ojo (o filtrar), pueden utilizar =hexdump=. En
    lo personal, les sugiero usar =hexdump -C core= para leer el
    contenido.

    Ojo ‚Äî Si usan este m√©todo, que puede parecer el m√°s sencillo, van
    a tener que considerar la ubicaci√≥n relativa a los /agujeros/ en
    memoria y archivos mapeados que no forman parte del core...
- Obtuve el mapa de memoria (extendido, para incluir informaci√≥n
  acerca de las p√°ginas limpias/sucias) usando =pmap -x 12345=. El
  resultado est√° en [[./donde_en_la_memoria/donde_en_la_memoria.pmap][donde_en_la_memoria.pmap]].
  - Hay informaci√≥n muy similar, aunque con diferencias de formato,
    obtenida de =/proc/12345/maps=: [[./donde_en_la_memoria/donde_en_la_memoria.maps][donde_en_la_memoria.maps]]
  - Y la misma informaci√≥n, ampliada y en formato de registros en vez
    de tabular, en [[./donde_en_la_memoria/donde_en_la_memoria.smaps][donde_en_la_memoria.smaps]]

** ¬øQu√© entregar?

Tal vez a estas alturas est√©n ya un poco mareados. S√≠, estoy pidiendo
que apliquen conocimientos que no les d√≠ expl√≠citamente; a fin de
cuentas, el proyecto busca /integraci√≥n de conocimientos/ y una pizca
de pensamiento cr√≠tico autodidacta üòâ

Para la primera parte, quiero un /programa/ al cual yo le indique un
PID, y me genere un mapa como [[./donde_en_la_memoria/repr_visual_bash_rpi0][el que les doy como ejemplo]].

Para la segunda parte, basta con un documento de texto, indicando qu√©
herramienta utilizaron, c√≥mo la utilizaron, y qu√© descubrieron con
ella (si es que descubrieron /algo/; pueden tambi√©n reportar que
determinada herramienta o enfoque no les dio nada √∫til).

** ¬øC√≥mo se califica?

El 50% de la calificaci√≥n corresponde a cada parte del planteamiento.

*** Para la parte 1

- Entrega de un programa que intente resolver el planteamiento ‚áí 50%
  - De entrada: Cuenten con el 30%
  - Incluye documentaci√≥n con autores, estrategia, requisitos, etc. ‚áí 20%
- Puedo ejecutarlo (de ser necesario, compilarlo) /sin modificaci√≥n
  alguna/ ‚áí 10%
- Calidad del reconocimiento de las regiones de memoria ‚áí 10%
  - Texto, datos, heap, stack, bibliotecas, espacios vac√≠os... ¬øAlguna
    hip√≥tesis para las regiones que yo marqu√© como ¬´?¬ª?
- Representaci√≥n visual ‚áí Hasta 15%
  - Similar a mi ejemplo, 10%
  - Salida a color, gr√°fica, interactiva con alg√∫n detalle
    /interesante/, 5%
- Universalidad ‚áí 15%
  - Funciona con mis archivos de ejemplo, 5%
  - Funciona con procesos cualquiera de mi sistema, sean sencillos o
    complejos, 5%
  - Funciona en equipos de 32 o 64 (ok, 48) bits sin problemas, 5%

*** Para la parte 2
- Entregado, explicando el proceso que siguen ‚áí 50%
- Ubican correctamente (indicando direcci√≥n de memoria y secci√≥n a la
  que corresponde) d√≥nde est√°n las cadenas de texto origen ‚áí 15%
- Ubican correctamente d√≥nde est√°n las cadenas de texto que son
  entregadas a =printf()=, diferenci√°ndolas de las anteriores donde
  haga falta ‚áí 15%
- Ubican correctamente d√≥nde est√°n los nombres de las funciones y
  variables ‚áí 10%
  - Ubicarlas, 5%
  - Explicar por qu√© hay algunas que /no pueden ser halladas/, 5%
- Ubican correctamente otros s√≠mbolos y valores ‚áí 10%
  - Valores que /no/ sean cadenas de texto ‚áí 5%
  - Otros elementos que forman parte de la tabla de s√≠mbolos, pero no
    forman parte de mi fuente (¬øqu√© son?) ‚áí 5%
